--- a/upnp/inc/upnp.h	2017-11-14 12:02:53.000000000 +0100
+++ b/upnp/inc/upnp.h	2018-04-25 13:10:31.873518330 +0200
@@ -65,6 +65,7 @@
 #include <openssl/ssl.h>
 #endif
 
+#define HEADER_SIZE  256
 #define LINE_SIZE  (size_t)180
 #define NAME_SIZE  (size_t)256
 #define MNFT_NAME_SIZE  64
@@ -2762,6 +2763,20 @@
  */
 EXPORT_SPEC void UpnpRemoveAllVirtualDirs(void);
 
+/** \brief add a custom header to
+ *  the internal web server. All HTTP responses will contain the
+ *  specified header.
+ *
+ *  \return [int] An integer representing one of the following:
+ *    \begin{itemize}
+ *       \item {\tt UPPN_E_SUCCESS}: The operation completed successfully.
+ *       \item {\tt UPNP_E_INVALID_ARGUMENT}: {\bf header_string} is empty.
+ *    \end{itemize}
+ */
+EXPORT_SPEC int UpnpAddCustomHTTPHeader(
+    IN const char* header_string  /** Header to add (\r\n termination not needed) */
+    );
+
 /* @} Web Server API */
 
 #ifdef __cplusplus
--- a/upnp/src/api/upnpapi.c	2017-11-14 12:02:53.000000000 +0100
+++ b/upnp/src/api/upnpapi.c	2018-04-25 13:23:33.601544810 +0200
@@ -127,6 +127,9 @@
 /*! Mini server thread pool. */
 ThreadPool gMiniServerThreadPool;
 
+/*! user defined http headers */
+membuffer gUserHTTPHeaders;
+
 /*! Flag to indicate the state of web server */
 WebServerState bWebServerState = WEB_SERVER_DISABLED;
 
@@ -440,6 +443,7 @@
 
 #if EXCLUDE_WEB_SERVER == 0
 	membuffer_init(&gDocumentRootDir);
+	membuffer_init( &gUserHTTPHeaders );
 	retVal = UpnpEnableWebserver(WEB_SERVER_ENABLED);
 	if (retVal != UPNP_E_SUCCESS) {
 		UpnpFinish();
@@ -707,6 +711,7 @@
 	ithread_mutex_destroy(&gUUIDMutex);
 	/* remove all virtual dirs */
 	UpnpRemoveAllVirtualDirs();
+	membuffer_destroy(&gUserHTTPHeaders);
 	UpnpSdkInit = 0;
 	UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
 		"Exiting UpnpFinish: UpnpSdkInit is :%d:\n", UpnpSdkInit);
@@ -717,6 +722,43 @@
 	return UPNP_E_SUCCESS;
 }
 
+/**************************************************************************
+ * Function: UpnpAddHTTPHeader
+ *
+ * Parameters:
+ *	IN const char *header: string to be added to the HTTP response
+ *
+ * Description:
+ *	This function adds a HTTP header to the response.
+ *  For example "X-User-Agent: something" (\r\n termination is done
+ *  automatically.
+ *
+ *  Return Values: int
+ *     UPNP_E_SUCCESS if successful else returns appropriate error
+ ***************************************************************************/
+int
+UpnpAddCustomHTTPHeader( IN const char *header_string )
+{
+    char header[HEADER_SIZE];
+
+    if( UpnpSdkInit != 1 ) {
+        // SDK is not initialized
+        return UPNP_E_FINISH;
+    }
+
+    if( ( header_string == NULL ) || ( strlen( header_string ) == 0 ) ||
+        ( strlen(header_string) > HEADER_SIZE )) {
+        return UPNP_E_INVALID_PARAM;
+    }
+
+
+    if (gUserHTTPHeaders.length > 0)
+        membuffer_append(&gUserHTTPHeaders, "\r\n", 2);
+    membuffer_append(&gUserHTTPHeaders, header_string, strlen(header_string));
+    return UPNP_E_SUCCESS;
+}
+
+
 unsigned short UpnpGetServerPort(void)
 {
 	if (UpnpSdkInit != 1)
--- a/upnp/src/genlib/net/http/httpreadwrite.c	2017-11-14 12:02:53.000000000 +0100
+++ b/upnp/src/genlib/net/http/httpreadwrite.c	2018-04-25 13:23:28.529544638 +0200
@@ -1500,7 +1500,7 @@
 	memset(tempbuf, 0, sizeof(tempbuf));
 	va_start(argp, fmt);
 	while ((c = *fmt++)) {
-		if (c == 's') {
+		if (c == 's' || c == 'A') {
 			/* C string */
 			s = (char *)va_arg(argp, char *);
 			assert(s);
@@ -1508,6 +1508,10 @@
 				   "Adding a string : %s\n", s);
 			if (membuffer_append(buf, s, strlen(s)))
 				goto error_handler;
+			if( c == 'A' && membuffer_append( buf, "\r\n", 2 ) != 0 ) 
+			{
+				goto error_handler;
+			}
 		} else if (c == 'K') {
 			/* Add Chunky header */
 			if (membuffer_append(buf, "TRANSFER-ENCODING: chunked\r\n",
--- a/upnp/src/genlib/net/http/webserver.c	2017-11-14 12:02:53.000000000 +0100
+++ b/upnp/src/genlib/net/http/webserver.c	2018-04-25 13:19:32.577536645 +0200
@@ -1248,20 +1248,21 @@
 		/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */
 		/* Transfer-Encoding: chunked */
 		if (http_MakeMessage(headers, resp_major, resp_minor,
-		    "R" "T" "GKLD" "s" "tcS" "Xc" "sCc",
+		    "R" "T" "GKLD" "s" "tcS" "AXc" "sCc",
 		    HTTP_PARTIAL_CONTENT,	/* status code */
 		    UpnpFileInfo_get_ContentType(finfo), /* content type */
 		    RespInstr,	/* range info */
 		    RespInstr,	/* language info */
 		    "LAST-MODIFIED: ",
 		    &aux_LastModified,
+	            gUserHTTPHeaders.buf,
 		    X_USER_AGENT, extra_headers) != 0) {
 			goto error_handler;
 		}
 	} else if (RespInstr->IsRangeActive && !RespInstr->IsChunkActive) {
 		/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */
 		if (http_MakeMessage(headers, resp_major, resp_minor,
-		    "R" "N" "T" "GLD" "s" "tcS" "Xc" "sCc",
+		    "R" "N" "T" "GLD" "s" "tcS" "AXc" "sCc",
 		    HTTP_PARTIAL_CONTENT,	/* status code */
 		    RespInstr->ReadSendSize,	/* content length */
 		    UpnpFileInfo_get_ContentType(finfo), /* content type */
@@ -1269,18 +1270,20 @@
 		    RespInstr,	/* language info */
 		    "LAST-MODIFIED: ",
 		    &aux_LastModified,
+	            gUserHTTPHeaders.buf,
 		    X_USER_AGENT, extra_headers) != 0) {
 			goto error_handler;
 		}
 	} else if (!RespInstr->IsRangeActive && RespInstr->IsChunkActive) {
 		/* Transfer-Encoding: chunked */
 		if (http_MakeMessage(headers, resp_major, resp_minor,
-		    "RK" "TLD" "s" "tcS" "Xc" "sCc",
+		    "RK" "TLD" "s" "tcS" "AXc" "sCc",
 		    HTTP_OK,	/* status code */
 		    UpnpFileInfo_get_ContentType(finfo), /* content type */
 		    RespInstr,	/* language info */
 		    "LAST-MODIFIED: ",
 		    &aux_LastModified,
+	            gUserHTTPHeaders.buf,
 		    X_USER_AGENT, extra_headers) != 0) {
 			goto error_handler;
 		}
@@ -1288,25 +1291,27 @@
 		/* !RespInstr->IsRangeActive && !RespInstr->IsChunkActive */
 		if (RespInstr->ReadSendSize >= 0) {
 			if (http_MakeMessage(headers, resp_major, resp_minor,
-			    "R" "N" "TLD" "s" "tcS" "Xc" "sCc",
+			    "R" "N" "TLD" "s" "tcS" "AXc" "sCc",
 			    HTTP_OK,	/* status code */
 			    RespInstr->ReadSendSize,	/* content length */
 			    UpnpFileInfo_get_ContentType(finfo), /* content type */
 			    RespInstr,	/* language info */
 			    "LAST-MODIFIED: ",
 			    &aux_LastModified,
+			    gUserHTTPHeaders.buf,
 			    X_USER_AGENT,
 			    extra_headers) != 0) {
 				goto error_handler;
 			}
 		} else {
 			if (http_MakeMessage(headers, resp_major, resp_minor,
-			    "R" "TLD" "s" "tcS" "Xc" "sCc",
+			    "R" "TLD" "s" "tcS" "AXc" "sCc",
 			    HTTP_OK,	/* status code */
 			    UpnpFileInfo_get_ContentType(finfo), /* content type */
 			    RespInstr,	/* language info */
 			    "LAST-MODIFIED: ",
 			    &aux_LastModified,
+		            gUserHTTPHeaders.buf,
 			    X_USER_AGENT,
 			    extra_headers) != 0) {
 				goto error_handler;
@@ -1542,8 +1547,8 @@
 				&RespInstr);
 			/* Send response. */
 			http_MakeMessage(&headers, 1, 1,
-				"RTLSXcCc",
-				ret, "text/html", &RespInstr, X_USER_AGENT);
+				"RTLSAXcCc",
+				ret, "text/html", &RespInstr, gUserHTTPHeaders.buf, X_USER_AGENT);
 			http_SendMessage(info, &timeout, "b",
 				headers.buf, headers.length);
 			break;
--- a/upnp/src/inc/upnpapi.h	2017-11-14 12:02:53.000000000 +0100
+++ b/upnp/src/inc/upnpapi.h	2018-04-25 13:20:37.881538857 +0200
@@ -41,6 +41,7 @@
 
 
 #include "client_table.h"
+#include "membuffer.h"
 #include "upnp.h"
 #include "VirtualDir.h"		/* for struct VirtualDirCallbacks */
 
@@ -317,6 +318,7 @@
 	UpnpClient_Handle Hnd);
 
 
+extern membuffer gUserHTTPHeaders;
 extern WebServerState bWebServerState;
 
 
